{"version":3,"file":"index.browser.js","sources":["../src/AuthorsMap.ts","../src/VariablesMap.ts","../src/index.ts"],"sourcesContent":["/**\n * Class that helps keep track of authors and allows for easy conversion to list format when\n * generating the final Metadata file.\n *\n * @export\n * @class AuthorsMap\n * @typedef {AuthorsMap}\n */\nexport class AuthorsMap {\n  /**\n   * Field that keeps track of the authors in a map.\n   *\n   * @private\n   * @type {({ [key: string]: {} | string })}\n   */\n  private authors: { [key: string]: {} | string }; // Define the type for authors\n\n  /**\n   * Creates an empty instance of authors map. Doesn't generate default metadata because\n   * can't assume anything about the authors.\n   *\n   * @constructor\n   */\n  constructor() {\n    this.authors = {};\n  }\n\n  /**\n   * Returns the final list format of the authors according to Psych-DS standards.\n   *\n   * @returns {({} | string)[]} - List of authors\n   */\n  getList(): ({} | string)[] {\n    const author_list = [];\n    for (const key of Object.keys(this.authors)) {\n      author_list.push(this.authors[key]);\n    }\n    return author_list;\n  }\n\n  /**\n   * Method that creates an author. This method can also be used to overwrite existing authors\n   * with the same name in order to update fields.\n   *\n   * @param {{\n   *     type?: string;\n   *     name: string;\n   *     givenName?: string; // required\n   *     familyName?: string;\n   *     identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n   *   }} fields - All the required or possible fields associated with listing an author according to Psych-DS standards.\n   */\n  setAuthor(fields: {\n    type?: string;\n    name: string;\n    givenName?: string; // required\n    familyName?: string;\n    identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n  }): void {\n    if (Object.keys(fields).length == 1) {\n      // if only name, just add to list without dict format, according to documentation\n      this.authors[fields.name] = fields.name;\n      return;\n    }\n    const new_author: { [key: string]: any } = {}; // Define an empty object to store the variables\n    new_author[\"name\"] = fields[\"name\"]; // to ensure that name is always first\n    delete fields[\"name\"];\n\n    for (const key in fields) {\n      // Check if the property is defined and not null\n      if (fields[key] !== undefined && fields[key] !== null) {\n        new_author[key] = fields[key];\n      }\n    }\n\n    this.authors[new_author.name] = new_author;\n  }\n\n  /**\n   * Method that fetches an author object allowing user to update (in existing workflow should not be necessary).\n   *\n   * @param {string} name - Name of author to be used as key.\n   * @returns {{}} - Object with author information.\n   */\n  getAuthor(name: string): {} {\n    if (name in this.authors) {\n      return this.authors[name];\n    } else return {};\n  }\n}\n","/**\n * Custom class that stores and handles the storage, update and retrieval of variable metadata.\n *\n * @export\n * @class VariablesMap\n * @typedef {VariablesMap}\n */\nexport class VariablesMap {\n  /**\n   * Field that holds a map of the current variables allowing for fast look-up.\n   *\n   * @private\n   * @type {{}}\n   */\n  private variables: {};\n\n  /**\n   *  Creates the VariablesMap bycalling generateDefaultVariables() method to\n   * generate the basic metadata common to every dataset_description.json file.\n   *\n   * @constructor\n   */\n  constructor() {\n    this.generateDefaultVariables();\n  }\n\n  /**\n   * Generates the default variables shared between every JsPsych experiment and fills in\n   * with filler descriptions for reseachers to change.\n   */\n  generateDefaultVariables(): void {\n    this.variables = {};\n\n    const trial_type_var = {\n      type: \"PropertyValue\",\n      name: \"trial_type\",\n      description: {\n        default: \"unknown\",\n        jsPsych: \"The name of the plugin used to run the trial.\",\n      },\n      value: \"string\",\n    };\n    this.setVariable(trial_type_var);\n\n    const trial_index_var = {\n      type: \"PropertyValue\",\n      name: \"trial_index\",\n      description: {\n        default: \"unknown\",\n        jsPsych: \"The index of the current trial across the whole experiment.\",\n      },\n      value: \"numeric\",\n    };\n    this.setVariable(trial_index_var);\n\n    const time_elapsed_var = {\n      type: \"PropertyValue\",\n      name: \"time_elapsed\",\n      description: {\n        default: \"unknown\",\n        jsPsych:\n          \"The number of milliseconds between the start of the experiment and when the trial ended.\",\n      },\n      value: \"numeric\",\n    };\n    this.setVariable(time_elapsed_var);\n  }\n\n  /**\n   * Returns a list of the variables instead of an object according to the Psych-DS format.\n   *\n   * @returns {{}[]} - The list of variables represented as objects.\n   */\n  getList(): {}[] {\n    var var_list = [];\n\n    // need to check that this works as intended\n    for (const key of Object.keys(this.variables)) {\n      const variable = this.variables[key];\n      const description = variable[\"description\"];\n      const numKeys = Object.keys(description).length;\n\n      if (numKeys === 0) console.error(\"Empty description\"); // error: description empty\n      else if (numKeys === 1) {\n        // description becomes single field (assumed to be default)\n        const key = Object.keys(description)[0];\n        variable[\"description\"] = description[key];\n      } else if (numKeys == 2) {\n        delete description[\"default\"]; // deletes default\n\n        if (Object.keys(description).length == 1) {\n          // error checking that it reduced to one key\n          const key = Object.keys(description)[0];\n          variable[\"description\"] = description[key];\n        }\n      } else if (numKeys > 2) {\n        // deletes default\n        delete description[\"default\"];\n      }\n\n      var_list.push(variable);\n    }\n    return var_list;\n  }\n\n  /**\n   * Allows user to set a variable and includes all the fields that are possible according to\n   * Psych-DS guidelines. Only requires the name field which it uses a key to map to the variable.\n   * Can also be used to overwrite existing variables if they have the same name.\n   *\n   * @param {{\n   *     type?: string;\n   *     name: string; // required\n   *     description?: string | {};\n   *     value?: string; // string, boolean, or number\n   *     identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n   *     minValue?: number;\n   *     maxValue?: number;\n   *     levels?: string[] | []; // technically property values in the other one but not sure how to format it\n   *     levelsOrdered?: boolean;\n   *     na?: boolean;\n   *     naValue?: string;\n   *     alternateName?: string;\n   *     privacy?: string;\n   *   }} fields - Input fields as specified by Psych-DS standards.\n   */\n  setVariable(fields: {\n    type?: string;\n    name: string; // required\n    description?: string | {};\n    value?: string; // string, boolean, or number\n    identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n    minValue?: number;\n    maxValue?: number;\n    levels?: string[] | []; // technically property values in the other one but not sure how to format it\n    levelsOrdered?: boolean;\n    na?: boolean;\n    naValue?: string;\n    alternateName?: string;\n    privacy?: string;\n  }): void {\n    const new_variable: { [key: string]: any } = {}; // Define an empty object to store the variables\n\n    for (const key in fields) {\n      // Check if the property is defined and not null\n      if (fields[key] !== undefined && fields[key] !== null) {\n        new_variable[key] = fields[key];\n      }\n    }\n\n    this.variables[new_variable.name] = new_variable;\n  }\n\n  /**\n   * Allows you to get information for a single variable returning empty dict if it doesn't exist.\n   * Allows you to update fields but not recommended in favor of updateVariable.\n   *\n   * @param {string} name - Name of variable to map to.\n   * @returns {{}} - Variable information or empty dict if doesn't exist\n   */\n  getVariable(name: string): {} {\n    return this.variables[name] || {};\n  }\n\n  containsVariable(name: string): boolean {\n    return name in this.variables;\n  }\n\n  /**\n   * Method that gets a list of the names of variables.\n   *\n   * @returns {string[]} - String list containing names of existing variables.\n   */\n  getVariableNames(): string[] {\n    var var_list = [];\n    for (const key of Object.keys(this.variables)) {\n      var_list.push(this.variables[key][\"name\"]);\n    }\n\n    return var_list;\n  }\n\n  /**\n   * Allows you to update a variable or add a value in the case of updating values. In other situations will\n   * replace the existing value with the new value. Has special cases and logic for levels and names making it\n   * easier to update variable values.\n   *\n   * @param {string} var_name\n   * @param {string} field_name\n   * @param {(string | boolean | number | {})} added_value\n   */\n  updateVariable(\n    var_name: string,\n    field_name: string,\n    added_value: string | boolean | number | {}\n  ): void {\n    const updated_var = this.getVariable(var_name);\n\n    if (Object.keys(updated_var).length === 0) {\n      // error checking to see variable exists\n      console.error(`Variable \"${var_name}\" does not exist.`);\n      return;\n    }\n\n    if (field_name === \"levels\") {\n      this.updateLevels(updated_var, added_value);\n    } else if (field_name === \"minValue\" || field_name === \"maxValue\") {\n      this.updateMinMax(updated_var, added_value, field_name);\n    } else if (field_name === \"description\") {\n      this.updateDescription(updated_var, added_value);\n    } else if (field_name === \"name\") {\n      this.updateName(updated_var, added_value);\n    } else {\n      updated_var[field_name] = added_value;\n    }\n  }\n\n  private updateLevels(updated_var, added_value) {\n    // for levels adds value, creating new array if necessary\n    if (!Array.isArray(updated_var[\"levels\"])) {\n      updated_var[\"levels\"] = [];\n    }\n    if (!updated_var[\"levels\"].includes(added_value)) {\n      updated_var[\"levels\"].push(added_value);\n    }\n  }\n\n  private updateMinMax(updated_var, added_value, field_name) {\n    // check if min or max\n    if (!(\"minValue\" in updated_var) || !(\"maxValue\" in updated_var)) {\n      updated_var[\"maxValue\"] = updated_var[\"minValue\"] = added_value;\n      return;\n    }\n\n    // redundant checks, including them because of current formatting but want to delete field_name\n    if (field_name === \"minValue\" && updated_var[\"minValue\"] > added_value) {\n      updated_var[\"minValue\"] = added_value;\n    } else if (field_name === \"maxValue\" && updated_var[\"maxValue\"] < added_value) {\n      updated_var[\"maxValue\"] = added_value;\n    }\n  }\n\n  // used to handle logic for dict descriptions\n  private updateDescription(updated_var, added_value) {\n    // getting key and value for new value for clarity\n    const add_key = Object.keys(added_value)[0];\n    const add_value = Object.values(added_value)[0];\n\n    if (add_key === \"undefined\" || add_value === \"undefined\") {\n      console.error(\"New value is passed in correct format\");\n      return;\n    }\n\n    var exists = false;\n    // creates map for description if doesn't exist\n    if (typeof updated_var[\"description\"] !== \"object\") {\n      updated_var[\"description\"] = {};\n    }\n\n    // appends key to other keys if default value/description are the same already exist to keep metadata shorter\n    Object.entries(updated_var[\"description\"]).forEach(([key, value]) => {\n      if (value === add_value) {\n        if (!key.includes(add_key)) {\n          // substring check to see it doesn't exist\n          delete updated_var[\"description\"][key]; // deletes old version\n          updated_var[\"description\"][key + \", \" + add_key] = add_value;\n        }\n        exists = true;\n      }\n    });\n\n    // if value description doesn't exist previous, adds\n    if (!exists) Object.assign(updated_var[\"description\"], added_value); // Assuming added_value is { chatplugin: \"response that user input\" }\n  }\n\n  private updateName(updated_var, added_value) {\n    const old_name = updated_var[\"name\"];\n    updated_var[\"name\"] = added_value;\n    delete this.variables[old_name];\n\n    this.setVariable(\n      updated_var as {\n        type?: string;\n        name: string;\n        description?: string | {};\n        value?: string;\n        identifier?: string;\n        minValue?: number;\n        maxValue?: number;\n        levels?: string[] | [];\n        levelsOrdered?: boolean;\n        na?: boolean;\n        naValue?: string;\n        alternateName?: string;\n        privacy?: string;\n      }\n    );\n  }\n\n  // if the field is already a dictionary\n  // if the new value that is being added doesn't match the old value\n  checkDescription(var_name, field_name, added_var): boolean {\n    if (field_name !== \"description\") return false;\n\n    const variable = this.getVariable(var_name);\n\n    if (Object.keys(variable).length === 0) {\n      console.error(\"Variable has not been initalized\");\n      return false;\n    }\n\n    const field = variable[field_name];\n\n    if (typeof field === \"undefined\") {\n      // will want to create a new field in this case, creates an error if not as a dict\n      console.error(\"Field has not been defined\");\n      return false;\n    }\n\n    if (field !== added_var || typeof field === \"object\") {\n      return true; // means that should be initalized to a dict\n    }\n\n    return false;\n  }\n\n  /**\n   * Allows you to delete a variable by key/name. Returns console error if not found.\n   *\n   * @param {string} var_name - Name of variable to be deleted.\n   */\n  deleteVariable(var_name: string): void {\n    if (var_name in this.variables) {\n      delete this.variables[var_name];\n    } else {\n      console.error(`Variable \"${var_name}\" does not exist.`);\n    }\n  }\n}\n","import { JsPsych } from \"jspsych\";\n\nimport { AuthorsMap } from \"./AuthorsMap\";\nimport { VariablesMap } from \"./VariablesMap\";\n\n/**\n * Class that handles the storage, update and retrieval of Metadata.\n *\n * @export\n * @class JsPsychMetadata\n * @typedef {JsPsychMetadata}\n */\nexport default class JsPsychMetadata {\n  /**\n   * Field that contains all metadata fields that aren't represented as a list.\n   *\n   * @private\n   * @type {{}}\n   */\n  private metadata: {};\n  /**\n   * Custom class that stores and handles the storage, update and retrieval of author metadata.\n   *\n   * @private\n   * @type {AuthorsMap}\n   */\n  private authors: AuthorsMap;\n  /**\n   * Custom class that stores and handles the storage, update and retrieval of variable metadata.\n   *\n   * @private\n   * @type {VariablesMap}\n   */\n  private variables: VariablesMap;\n\n  /** The cache is a dictionary of dictionaries, with the outer dictionary keyed by type of plugin\n   * and the inner dictionary keyed by variableName. This is so that even if we have two variables\n   * with the same name in different plugins, we can store their descriptions separately.\n   * @private\n   * @type {{}}\n   */\n  private cache: {};\n\n  /**\n   * Creates an instance of JsPsychMetadata while passing in JsPsych object to have access to context\n   *  allowing it to access the screen printing information.\n   *\n   * @constructor\n   * @param {JsPsych} JsPsych\n   */\n  constructor(private JsPsych: JsPsych) {\n    this.generateDefaultMetadata();\n  }\n  /**\n   * Method that fills in JsPsychMetadata class with all the universal fields with default information.\n   * This is automatically called whenever creating an instance of JsPsychMetadata and indicates all\n   * the required fields that need to filled in to be Psych-DS compliant.\n   */\n  generateDefaultMetadata(): void {\n    this.metadata = {};\n    this.setMetadataField(\"name\", \"title\");\n    this.setMetadataField(\"schemaVersion\", \"Psych-DS 0.4.0\");\n    this.setMetadataField(\"@context\", \"https://schema.org\");\n    this.setMetadataField(\"@type\", \"Dataset\");\n    this.setMetadataField(\"description\", \"Dataset generated using JsPsych\");\n    this.authors = new AuthorsMap();\n    this.variables = new VariablesMap();\n    this.cache = {};\n  }\n\n  /**\n   * Method that sets simple metadata fields. This method can also be used to update/overwrite existing fields.\n   *\n   * @param {string} key - Metadata field name\n   * @param {*} value - Data associated with the field\n   */\n  setMetadataField(key: string, value: any): void {\n    this.metadata[key] = value;\n  }\n\n  /**\n   * Simple get that accesses the data associated with a field.\n   *\n   * @param {string} key - Field name\n   * @returns {*} - Data associated with the field\n   */\n  getMetadataField(key: string): any {\n    return this.metadata[key];\n  }\n\n  /**\n   * Returns the final Metadata in a single javascript object. Bundles together the author and variables\n   * together in a list rather than object compliant with Psych-DS standards.\n   *\n   * @returns {{}} - Final Metadata object\n   */\n  getMetadata(): {} {\n    const res = this.metadata;\n    res[\"author\"] = this.authors.getList();\n    res[\"variableMeasured\"] = this.variables.getList();\n\n    return res;\n  }\n\n  /**\n   * Method that creates an author. This method can also be used to overwrite existing authors\n   * with the same name in order to update fields.\n   *\n   * @param {{\n   *     type?: string;\n   *     name: string;\n   *     givenName?: string;\n   *     familyName?: string;\n   *     identifier?: string;\n   *   }} fields - All the required or possible fields associated with listing an author according to Psych-DS standards.\n   */\n  setAuthor(fields: {\n    type?: string;\n    name: string;\n    givenName?: string; // required\n    familyName?: string;\n    identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n  }): void {\n    this.authors.setAuthor(fields);\n  }\n\n  /**\n   * Method that fetches an author object allowing user to update (in existing workflow should not be necessary).\n   *\n   * @param {string} name - Name of author to be used as key.\n   * @returns {{}} - Object with author information.\n   */\n  getAuthor(name: string): {} {\n    return this.authors.getAuthor(name);\n  }\n\n  /**\n   * Method that creates a variable. This method can also be used to overwrite variables with the same name\n   * as a way to update fields.\n   *\n   * @param {{\n   *     type?: string;\n   *     name: string; // required\n   *     description?: string | {};\n   *     value?: string; // string, boolean, or number\n   *     identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n   *     minValue?: number;\n   *     maxValue?: number;\n   *     levels?: string[] | []; // technically property values in the other one but not sure how to format it\n   *     levelsOrdered?: boolean;\n   *     na?: boolean;\n   *     naValue?: string;\n   *     alternateName?: string;\n   *     privacy?: string;\n   *   }} fields - Fields associated with the current Psych-DS standard.\n   */\n  setVariable(fields: {\n    type?: string;\n    name: string; // required\n    description?: string | {};\n    value?: string; // string, boolean, or number\n    identifier?: string; // identifier that distinguish across dataset (URL)\n    minValue?: number;\n    maxValue?: number;\n    levels?: string[] | []; // technically property values in the other one but not sure how to format it\n    levelsOrdered?: boolean;\n    na?: boolean;\n    naValue?: string;\n    alternateName?: string;\n    privacy?: string;\n  }): void {\n    this.variables.setVariable(fields);\n  }\n\n  /**\n   * Allows you to access a variable's information by using the name of the variable. Can\n   * be used to update fields within a variable, but suggest using updateVariable() to prevent errors.\n   *\n   * @param {string} name - Name of variable to be accessed\n   * @returns {{}} - Returns object of fields\n   */\n  getVariable(name: string): {} {\n    return this.variables.getVariable(name);\n  }\n\n  containsVariable(name: string): boolean {\n    return this.variables.containsVariable(name);\n  }\n\n  /**\n   * Allows you to update a variable or add a value in the case of updating values. In other situations will\n   * replace the existing value with the new value.\n   *\n   * @param {string} var_name - Name of variable to be updated.\n   * @param {string} field_name - Name of field to be updated.\n   * @param {(string | boolean | number | {})} added_value - Value to be used in the update.\n   */\n  updateVariable(\n    var_name: string,\n    field_name: string,\n    added_value: string | boolean | number | {}\n  ): void {\n    this.variables.updateVariable(var_name, field_name, added_value);\n  }\n\n  /**\n   * Allows you to delete a variable by key/name.\n   *\n   * @param {string} var_name - Name of variable to be deleted.\n   */\n  deleteVariable(var_name: string): void {\n    this.variables.deleteVariable(var_name);\n  }\n\n  /**\n   * Gets a list of all the variable names.\n   *\n   * @returns {string[]} - List of variable string names.\n   */\n  getVariableNames(): string[] {\n    return this.variables.getVariableNames();\n  }\n\n  /**\n   * Method that allows you to display metadata at the end of an experiment.\n   *\n   * @param {string} [elementId=\"jspsych-metadata-display\"] - Id for how to style the metadata. Defaults to default styling.\n   */\n  displayMetadata(display_element) {\n    const elementId = \"jspsych-metadata-display\";\n    const metadata_string = JSON.stringify(this.getMetadata(), null, 2);\n    // const display_element = this.JsPsych.getDisplayElement();\n    display_element.innerHTML += `<p id=\"jspsych-metadata-header\">Metadata</p><pre id=\"${elementId}\" class=\"jspsych-preformat\"></pre>`;\n    document.getElementById(elementId).textContent += metadata_string;\n  }\n\n  /**\n   * Method that begins a download for the dataset_description.json at the end of experiment.\n   * Allows you to download the metadat.\n   */\n  saveAsJsonFile(): void {\n    const jsonString = JSON.stringify(this.getMetadata(), null, 2);\n    const blob = new Blob([jsonString], { type: \"application/json\" });\n    const url = URL.createObjectURL(blob);\n\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = \"dataset_description.json\";\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n\n    URL.revokeObjectURL(url);\n  }\n\n  // passing in authors mapping and variables mapping and then goes through each variable\n  async generate(data, metadata = {}) {\n    // have it so that can pass in a dict of object that the researcher wants to do\n    if (typeof data === \"string\") {\n      data = JSON.parse(data);\n    }\n\n    for (const observation of data) {\n      await this.generateObservation(observation);\n    }\n\n    for (const key in metadata) {\n      this.processMetadata(metadata, key);\n    }\n    console.log(this.cache);\n    this.getMetadata();\n  }\n\n  private async generateObservation(observation) {\n    // variables can be thought of mapping of one column in a row\n    const pluginType = observation[\"trial_type\"];\n    const ignored_fields = new Set([\"trial_type\", \"trial_index\", \"time_elapsed\"]);\n\n    for (const variable in observation) {\n      const value = observation[variable];\n\n      if (ignored_fields.has(variable)) this.updateFields(variable, value, typeof value);\n      else if (this.containsVariable(variable)) {\n        // logic updates existing variable\n        await this.generateUpdate(variable, value, pluginType);\n      } else {\n        // logic to create new variable\n        await this.generateVariable(variable, value, pluginType);\n      }\n    }\n  }\n\n  private async generateVariable(variable, value, pluginType) {\n    // probably should work in a call to the plugin here\n    const description = await this.getPluginInfo(pluginType, variable);\n    const type = typeof value;\n\n    // probs should have update description called here\n    const new_var = {\n      type: \"PropertyValue\",\n      name: variable,\n      // If a description is not found from getPluginInfo, we pass a placeholder string\n      // instead of null so the system doesn't break *why doesn't null work?(promise error)*\n      description: description ? { [pluginType]: description } : { [pluginType]: \"unknown\" },\n      value: type,\n    };\n\n    this.setVariable(new_var);\n    this.updateFields(variable, value, type);\n  }\n\n  // hardest part is updating the description\n  // want to hardcode in the variables check\n  // logic is that probably won't need to be doing the dict thing\n  // implement all as description\n  private async generateUpdate(variable, value, pluginType) {\n    const type = typeof value;\n    const field_name = \"description\";\n    const description = await this.getPluginInfo(pluginType, variable);\n\n    // If a description is not found from getPluginInfo, we pass a placeholder string\n    // instead of null so the system doesn't break *why doesn't null work?(promise error)*\n    const new_description = description\n      ? { [pluginType]: description }\n      : { [pluginType]: \"unknown\" };\n\n    this.updateVariable(variable, field_name, new_description);\n    this.updateFields(variable, value, type);\n  }\n\n  private updateFields(variable, value, type) {\n    // calls updates where updateVariable handles logic\n    if (type !== \"number\" && type !== \"object\") {\n      this.updateVariable(variable, \"levels\", value);\n    }\n    // calls updates where updateVariable handles logic\n    if (type === \"number\") {\n      this.updateVariable(variable, \"minValue\", value);\n      this.updateVariable(variable, \"maxValue\", value);\n    }\n  }\n\n  private processMetadata(metadata, key) {\n    const value = metadata[key];\n\n    if (key === \"variables\") {\n      if (typeof value !== \"object\" || value === null) {\n        console.error(\"Variable object is either null or incorrect type\");\n        return;\n      }\n\n      // all of the variables must already exist because should have datapoints\n      for (let variable_key in value) {\n        if (!this.containsVariable(variable_key)) {\n          console.error(\"Metadata does not contain variable:\", variable_key);\n          continue;\n        }\n\n        const variable_parameters = value[variable_key];\n\n        if (typeof variable_parameters !== \"object\" || variable_parameters === null) {\n          console.error(\n            \"Parameters of variable:\",\n            variable_key,\n            \"is either null or incorrect type. The value\",\n            variable_parameters,\n            \"is either null or not an object.\"\n          );\n          continue;\n        }\n\n        for (const parameter in variable_parameters) {\n          // calling updates for each of the renamed parameters within variable/errors handled by method call\n          const parameter_value = variable_parameters[parameter];\n          this.updateVariable(variable_key, parameter, parameter_value);\n          if (parameter === \"name\") variable_key = parameter_value; // renames future instances if changing name\n        }\n      }\n    } else if (key === \"author\") {\n      if (typeof value !== \"object\" || value === null) {\n        console.error(\"Author object is not correct type\");\n        return;\n      }\n\n      for (const author_key in value) {\n        const author = value[author_key];\n        if (!(\"name\" in author)) author[\"name\"] = author_key;\n        this.setAuthor(author);\n      }\n    } else this.setMetadataField(key, value);\n  }\n\n  /**\n   * Gets the description of a variable in a plugin by fetching the source code of the plugin\n   * from a remote source (usually unpkg.com) as a string, passing the script to getJsdocsDescription\n   * to extract the description for the variable (present as JSDoc); caches the result for future use.\n   *\n   * @param {string} pluginType - The type of the plugin for which information is to be fetched.\n   * @param {string} variableName - The name of the variable for which information is to be fetched.\n   * @returns {Promise<string|null>} The description of the plugin variable if found, otherwise null.\n   * @throws Will throw an error if the fetch operation fails.\n   */\n  private async getPluginInfo(pluginType: string, variableName: string) {\n    // Check if the cache for the pluginType exists, if not initialize it\n    if (!this.cache[pluginType]) this.cache[pluginType] = {};\n\n    // If the variable already exists in the cache for the plugin, return the cached value\n    if (variableName in this.cache[pluginType]) {\n      return this.cache[pluginType][variableName];\n    }\n    // If not, we proceed to fetch script:\n\n    // Construct the URL for the unpkg service\n    const unpkgUrl = `https://unpkg.com/@jspsych/plugin-${pluginType}/src/index.ts`;\n\n    try {\n      // Fetch the script content from the unpkg URL\n      const response = await fetch(unpkgUrl);\n      const scriptContent = await response.text();\n\n      // Extract the JSDoc description for the variable from the script content\n      const description = getJsdocsDescription(scriptContent, variableName);\n\n      // Check again if the cache for the pluginType exists, if not initialize it\n      if (!this.cache[pluginType]) this.cache[pluginType] = {};\n\n      // Cache the description for the variable in the pluginType cache\n      this.cache[pluginType][variableName] = description;\n\n      // Return the description\n      return description;\n    } catch (error) {\n      console.error(`Failed to fetch info from ${unpkgUrl}:`, error);\n      // Error is likely due to 1)a fetch failure, or 2)no JSDoc comments in the script content matched.\n\n      //HANDLE FETCH FAILURE CASES\n\n      // In case of the latter, we cache the null value to prevent repeated fetch attempts.\n\n      if (!this.cache[pluginType]) this.cache[pluginType] = {};\n\n      this.cache[pluginType][variableName] = null;\n\n      return null;\n    }\n  }\n}\n\n/**\n * Extracts the description for a variable of a plugin from the JSDoc comments present in the script of the plugin. The script content is\n * drawn from the remotely hosted source file of the plugin through getPluginInfo. The script content is taken\n * as a string and Regex is used to extract the description.\n *\n *\n * @param {string} scriptContent - The content of the script from which the JSDoc description is to be extracted.\n * @param {string} variableName - The name of the variable for which the JSDoc description is to be extracted.\n * @returns {string} The extracted JSDoc description, cleaned and trimmed.\n */\nfunction getJsdocsDescription(scriptContent: string, variableName: string) {\n  // Regex to match part of the content that starts with 'parameters:' and ends with '};', which\n  // is parameters info. THIS MUST BE CHANGED TO data FOR NEW PLUGIN LAYOUT\n  const paramRegex = scriptContent.match(/parameters:\\s*{([\\s\\S]*?)};\\s*/).join();\n\n  // Regex that matches everything up to the variable name\n  const regex = new RegExp(`((.|\\n)*)(?=${variableName}:)`);\n\n  // Regex on paramRegex, to get everything from 'paramaters:' to the variable name.\n  const variableRegex = paramRegex.match(regex)[0];\n\n  // Finds the index of the last occurence of `/**` in the variableRegex string, and slices it from there\n  // to give the JSDoc comment for our variable.\n  const descrip = variableRegex.slice(variableRegex.lastIndexOf(\"/**\"));\n\n  // Regex to remove the leading and trailing '/**' and '*/' characters.\n  const clean = descrip.match(/(?<=\\*\\*)([\\s\\S]*?)(?=\\*\\/)/)[1];\n\n  //CLEANING:\n  // Regex to remove all newline characters.\n  const cleaner = clean.replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n\n  // Remove all '*' characters from the JSDoc comment.\n  const cleanest = cleaner.replace(/\\*/gm, \"\");\n\n  // Return the cleaned JSDoc comment, trimmed of leading and trailing whitespace\n  return cleanest.trim();\n}\n"],"names":["key","JsPsych"],"mappings":"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"}