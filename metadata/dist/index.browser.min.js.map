{"version":3,"file":"index.browser.min.js","sources":["../src/AuthorsMap.ts","../src/VariablesMap.ts","../src/index.ts"],"sourcesContent":["/**\n * Class that helps keep track of authors and allows for easy conversion to list format when\n * generating the final Metadata file.\n *\n * @export\n * @class AuthorsMap\n * @typedef {AuthorsMap}\n */\nexport class AuthorsMap {\n  /**\n   * Field that keeps track of the authors in a map.\n   *\n   * @private\n   * @type {({ [key: string]: {} | string })}\n   */\n  private authors: { [key: string]: {} | string }; // Define the type for authors\n\n  /**\n   * Creates an empty instance of authors map. Doesn't generate default metadata because\n   * can't assume anything about the authors.\n   *\n   * @constructor\n   */\n  constructor() {\n    this.authors = {};\n  }\n\n  /**\n   * Returns the final list format of the authors according to Psych-DS standards.\n   *\n   * @returns {({} | string)[]} - List of authors\n   */\n  getList(): ({} | string)[] {\n    const author_list = [];\n    for (const key of Object.keys(this.authors)) {\n      author_list.push(this.authors[key]);\n    }\n    return author_list;\n  }\n\n  /**\n   * Method that creates an author. This method can also be used to overwrite existing authors\n   * with the same name in order to update fields.\n   *\n   * @param {{\n   *     type?: string;\n   *     name: string;\n   *     givenName?: string; // required\n   *     familyName?: string;\n   *     identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n   *   }} fields - All the required or possible fields associated with listing an author according to Psych-DS standards.\n   */\n  setAuthor(fields: {\n    type?: string;\n    name: string;\n    givenName?: string; // required\n    familyName?: string;\n    identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n  }): void {\n    if (Object.keys(fields).length == 1) {\n      // if only name, just add to list without dict format, according to documentation\n      this.authors[fields.name] = fields.name;\n      return;\n    }\n    const new_author: { [key: string]: any } = {}; // Define an empty object to store the variables\n    new_author[\"name\"] = fields[\"name\"]; // to ensure that name is always first\n    delete fields[\"name\"];\n\n    for (const key in fields) {\n      // Check if the property is defined and not null\n      if (fields[key] !== undefined && fields[key] !== null) {\n        new_author[key] = fields[key];\n      }\n    }\n\n    this.authors[new_author.name] = new_author;\n  }\n\n  /**\n   * Method that fetches an author object allowing user to update (in existing workflow should not be necessary).\n   *\n   * @param {string} name - Name of author to be used as key.\n   * @returns {{}} - Object with author information.\n   */\n  getAuthor(name: string): {} {\n    if (name in this.authors) {\n      return this.authors[name];\n    } else return {};\n  }\n}\n","/**\n * Custom class that stores and handles the storage, update and retrieval of variable metadata.\n *\n * @export\n * @class VariablesMap\n * @typedef {VariablesMap}\n */\nexport class VariablesMap {\n  /**\n   * Field that holds a map of the current variables allowing for fast look-up.\n   *\n   * @private\n   * @type {{}}\n   */\n  private variables: {};\n\n  /**\n   *  Creates the VariablesMap bycalling generateDefaultVariables() method to\n   * generate the basic metadata common to every dataset_description.json file.\n   *\n   * @constructor\n   */\n  constructor() {\n    this.generateDefaultVariables();\n  }\n\n  /**\n   * Generates the default variables shared between every JsPsych experiment and fills in\n   * with filler descriptions for reseachers to change.\n   */\n  generateDefaultVariables(): void {\n    this.variables = {};\n\n    const trial_type_var = {\n      type: \"PropertyValue\",\n      name: \"trial_type\",\n      description: {\n        default: \"unknown\",\n        jsPsych: \"The name of the plugin used to run the trial.\",\n      },\n      value: \"string\",\n    };\n    this.setVariable(trial_type_var);\n\n    const trial_index_var = {\n      type: \"PropertyValue\",\n      name: \"trial_index\",\n      description: {\n        default: \"unknown\",\n        jsPsych: \"The index of the current trial across the whole experiment.\",\n      },\n      value: \"numeric\",\n    };\n    this.setVariable(trial_index_var);\n\n    const time_elapsed_var = {\n      type: \"PropertyValue\",\n      name: \"time_elapsed\",\n      description: {\n        default: \"unknown\",\n        jsPsych:\n          \"The number of milliseconds between the start of the experiment and when the trial ended.\",\n      },\n      value: \"numeric\",\n    };\n    this.setVariable(time_elapsed_var);\n  }\n\n  /**\n   * Returns a list of the variables instead of an object according to the Psych-DS format.\n   *\n   * @returns {{}[]} - The list of variables represented as objects.\n   */\n  getList(): {}[] {\n    var var_list = [];\n\n    // need to check that this works as intended\n    for (const key of Object.keys(this.variables)) {\n      const variable = this.variables[key];\n      const description = variable[\"description\"];\n      const numKeys = Object.keys(description).length;\n\n      if (numKeys === 0) console.error(\"Empty description\"); // error: description empty\n      else if (numKeys === 1) {\n        // description becomes single field (assumed to be default)\n        const key = Object.keys(description)[0];\n        variable[\"description\"] = description[key];\n      } else if (numKeys == 2) {\n        delete description[\"default\"]; // deletes default\n\n        if (Object.keys(description).length == 1) {\n          // error checking that it reduced to one key\n          const key = Object.keys(description)[0];\n          variable[\"description\"] = description[key];\n        }\n      } else if (numKeys > 2) {\n        // deletes default\n        delete description[\"default\"];\n      }\n\n      var_list.push(variable);\n    }\n    return var_list;\n  }\n\n  /**\n   * Allows user to set a variable and includes all the fields that are possible according to\n   * Psych-DS guidelines. Only requires the name field which it uses a key to map to the variable.\n   * Can also be used to overwrite existing variables if they have the same name.\n   *\n   * @param {{\n   *     type?: string;\n   *     name: string; // required\n   *     description?: string | {};\n   *     value?: string; // string, boolean, or number\n   *     identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n   *     minValue?: number;\n   *     maxValue?: number;\n   *     levels?: string[] | []; // technically property values in the other one but not sure how to format it\n   *     levelsOrdered?: boolean;\n   *     na?: boolean;\n   *     naValue?: string;\n   *     alternateName?: string;\n   *     privacy?: string;\n   *   }} fields - Input fields as specified by Psych-DS standards.\n   */\n  setVariable(fields: {\n    type?: string;\n    name: string; // required\n    description?: string | {};\n    value?: string; // string, boolean, or number\n    identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n    minValue?: number;\n    maxValue?: number;\n    levels?: string[] | []; // technically property values in the other one but not sure how to format it\n    levelsOrdered?: boolean;\n    na?: boolean;\n    naValue?: string;\n    alternateName?: string;\n    privacy?: string;\n  }): void {\n    const new_variable: { [key: string]: any } = {}; // Define an empty object to store the variables\n\n    for (const key in fields) {\n      // Check if the property is defined and not null\n      if (fields[key] !== undefined && fields[key] !== null) {\n        new_variable[key] = fields[key];\n      }\n    }\n\n    this.variables[new_variable.name] = new_variable;\n  }\n\n  /**\n   * Allows you to get information for a single variable returning empty dict if it doesn't exist.\n   * Allows you to update fields but not recommended in favor of updateVariable.\n   *\n   * @param {string} name - Name of variable to map to.\n   * @returns {{}} - Variable information or empty dict if doesn't exist\n   */\n  getVariable(name: string): {} {\n    return this.variables[name] || {};\n  }\n\n  containsVariable(name: string): boolean {\n    return name in this.variables;\n  }\n\n  /**\n   * Method that gets a list of the names of variables.\n   *\n   * @returns {string[]} - String list containing names of existing variables.\n   */\n  getVariableNames(): string[] {\n    var var_list = [];\n    for (const key of Object.keys(this.variables)) {\n      var_list.push(this.variables[key][\"name\"]);\n    }\n\n    return var_list;\n  }\n\n  /**\n   * Allows you to update a variable or add a value in the case of updating values. In other situations will\n   * replace the existing value with the new value. Has special cases and logic for levels and names making it\n   * easier to update variable values.\n   *\n   * @param {string} var_name\n   * @param {string} field_name\n   * @param {(string | boolean | number | {})} added_value\n   */\n  updateVariable(\n    var_name: string,\n    field_name: string,\n    added_value: string | boolean | number | {}\n  ): void {\n    const updated_var = this.getVariable(var_name);\n\n    if (Object.keys(updated_var).length === 0) {\n      // error checking to see variable exists\n      console.error(`Variable \"${var_name}\" does not exist.`);\n      return;\n    }\n\n    if (field_name === \"levels\") {\n      this.updateLevels(updated_var, added_value);\n    } else if (field_name === \"minValue\" || field_name === \"maxValue\") {\n      this.updateMinMax(updated_var, added_value, field_name);\n    } else if (field_name === \"description\") {\n      this.updateDescription(updated_var, added_value);\n    } else if (field_name === \"name\") {\n      this.updateName(updated_var, added_value);\n    } else {\n      updated_var[field_name] = added_value;\n    }\n  }\n\n  private updateLevels(updated_var, added_value) {\n    // for levels adds value, creating new array if necessary\n    if (!Array.isArray(updated_var[\"levels\"])) {\n      updated_var[\"levels\"] = [];\n    }\n    if (!updated_var[\"levels\"].includes(added_value)) {\n      updated_var[\"levels\"].push(added_value);\n    }\n  }\n\n  private updateMinMax(updated_var, added_value, field_name) {\n    // check if min or max\n    if (!(\"minValue\" in updated_var) || !(\"maxValue\" in updated_var)) {\n      updated_var[\"maxValue\"] = updated_var[\"minValue\"] = added_value;\n      return;\n    }\n\n    // redundant checks, including them because of current formatting but want to delete field_name\n    if (field_name === \"minValue\" && updated_var[\"minValue\"] > added_value) {\n      updated_var[\"minValue\"] = added_value;\n    } else if (field_name === \"maxValue\" && updated_var[\"maxValue\"] < added_value) {\n      updated_var[\"maxValue\"] = added_value;\n    }\n  }\n\n  // used to handle logic for dict descriptions\n  private updateDescription(updated_var, added_value) {\n    // getting key and value for new value for clarity\n    const add_key = Object.keys(added_value)[0];\n    const add_value = Object.values(added_value)[0];\n\n    if (add_key === \"undefined\" || add_value === \"undefined\") {\n      console.error(\"New value is passed in correct format\");\n      return;\n    }\n\n    var exists = false;\n    // creates map for description if doesn't exist\n    if (typeof updated_var[\"description\"] !== \"object\") {\n      updated_var[\"description\"] = {};\n    }\n\n    // appends key to other keys if default value/description are the same already exist to keep metadata shorter\n    Object.entries(updated_var[\"description\"]).forEach(([key, value]) => {\n      if (value === add_value) {\n        if (!key.includes(add_key)) {\n          // substring check to see it doesn't exist\n          delete updated_var[\"description\"][key]; // deletes old version\n          updated_var[\"description\"][key + \", \" + add_key] = add_value;\n        }\n        exists = true;\n      }\n    });\n\n    // if value description doesn't exist previous, adds\n    if (!exists) Object.assign(updated_var[\"description\"], added_value); // Assuming added_value is { chatplugin: \"response that user input\" }\n  }\n\n  private updateName(updated_var, added_value) {\n    const old_name = updated_var[\"name\"];\n    updated_var[\"name\"] = added_value;\n    delete this.variables[old_name];\n\n    this.setVariable(\n      updated_var as {\n        type?: string;\n        name: string;\n        description?: string | {};\n        value?: string;\n        identifier?: string;\n        minValue?: number;\n        maxValue?: number;\n        levels?: string[] | [];\n        levelsOrdered?: boolean;\n        na?: boolean;\n        naValue?: string;\n        alternateName?: string;\n        privacy?: string;\n      }\n    );\n  }\n\n  // if the field is already a dictionary\n  // if the new value that is being added doesn't match the old value\n  checkDescription(var_name, field_name, added_var): boolean {\n    if (field_name !== \"description\") return false;\n\n    const variable = this.getVariable(var_name);\n\n    if (Object.keys(variable).length === 0) {\n      console.error(\"Variable has not been initalized\");\n      return false;\n    }\n\n    const field = variable[field_name];\n\n    if (typeof field === \"undefined\") {\n      // will want to create a new field in this case, creates an error if not as a dict\n      console.error(\"Field has not been defined\");\n      return false;\n    }\n\n    if (field !== added_var || typeof field === \"object\") {\n      return true; // means that should be initalized to a dict\n    }\n\n    return false;\n  }\n\n  /**\n   * Allows you to delete a variable by key/name. Returns console error if not found.\n   *\n   * @param {string} var_name - Name of variable to be deleted.\n   */\n  deleteVariable(var_name: string): void {\n    if (var_name in this.variables) {\n      delete this.variables[var_name];\n    } else {\n      console.error(`Variable \"${var_name}\" does not exist.`);\n    }\n  }\n}\n","import { JsPsych } from \"jspsych\";\n\nimport { AuthorsMap } from \"./AuthorsMap\";\nimport { VariablesMap } from \"./VariablesMap\";\n\n/**\n * Class that handles the storage, update and retrieval of Metadata.\n *\n * @export\n * @class JsPsychMetadata\n * @typedef {JsPsychMetadata}\n */\nexport default class JsPsychMetadata {\n  /**\n   * Field that contains all metadata fields that aren't represented as a list.\n   *\n   * @private\n   * @type {{}}\n   */\n  private metadata: {};\n  /**\n   * Custom class that stores and handles the storage, update and retrieval of author metadata.\n   *\n   * @private\n   * @type {AuthorsMap}\n   */\n  private authors: AuthorsMap;\n  /**\n   * Custom class that stores and handles the storage, update and retrieval of variable metadata.\n   *\n   * @private\n   * @type {VariablesMap}\n   */\n  private variables: VariablesMap;\n\n  /** The cache is a dictionary of dictionaries, with the outer dictionary keyed by type of plugin\n   * and the inner dictionary keyed by variableName. This is so that even if we have two variables\n   * with the same name in different plugins, we can store their descriptions separately.\n   * @private\n   * @type {{}}\n   */\n  private cache: {};\n\n  /**\n   * Creates an instance of JsPsychMetadata while passing in JsPsych object to have access to context\n   *  allowing it to access the screen printing information.\n   *\n   * @constructor\n   * @param {JsPsych} JsPsych\n   */\n  constructor(private JsPsych: JsPsych) {\n    this.generateDefaultMetadata();\n  }\n  /**\n   * Method that fills in JsPsychMetadata class with all the universal fields with default information.\n   * This is automatically called whenever creating an instance of JsPsychMetadata and indicates all\n   * the required fields that need to filled in to be Psych-DS compliant.\n   */\n  generateDefaultMetadata(): void {\n    this.metadata = {};\n    this.setMetadataField(\"name\", \"title\");\n    this.setMetadataField(\"schemaVersion\", \"Psych-DS 0.4.0\");\n    this.setMetadataField(\"@context\", \"https://schema.org\");\n    this.setMetadataField(\"@type\", \"Dataset\");\n    this.setMetadataField(\"description\", \"Dataset generated using JsPsych\");\n    this.authors = new AuthorsMap();\n    this.variables = new VariablesMap();\n    this.cache = {};\n  }\n\n  /**\n   * Method that sets simple metadata fields. This method can also be used to update/overwrite existing fields.\n   *\n   * @param {string} key - Metadata field name\n   * @param {*} value - Data associated with the field\n   */\n  setMetadataField(key: string, value: any): void {\n    this.metadata[key] = value;\n  }\n\n  /**\n   * Simple get that accesses the data associated with a field.\n   *\n   * @param {string} key - Field name\n   * @returns {*} - Data associated with the field\n   */\n  getMetadataField(key: string): any {\n    return this.metadata[key];\n  }\n\n  /**\n   * Returns the final Metadata in a single javascript object. Bundles together the author and variables\n   * together in a list rather than object compliant with Psych-DS standards.\n   *\n   * @returns {{}} - Final Metadata object\n   */\n  getMetadata(): {} {\n    const res = this.metadata;\n    res[\"author\"] = this.authors.getList();\n    res[\"variableMeasured\"] = this.variables.getList();\n\n    return res;\n  }\n\n  /**\n   * Method that creates an author. This method can also be used to overwrite existing authors\n   * with the same name in order to update fields.\n   *\n   * @param {{\n   *     type?: string;\n   *     name: string;\n   *     givenName?: string;\n   *     familyName?: string;\n   *     identifier?: string;\n   *   }} fields - All the required or possible fields associated with listing an author according to Psych-DS standards.\n   */\n  setAuthor(fields: {\n    type?: string;\n    name: string;\n    givenName?: string; // required\n    familyName?: string;\n    identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n  }): void {\n    this.authors.setAuthor(fields);\n  }\n\n  /**\n   * Method that fetches an author object allowing user to update (in existing workflow should not be necessary).\n   *\n   * @param {string} name - Name of author to be used as key.\n   * @returns {{}} - Object with author information.\n   */\n  getAuthor(name: string): {} {\n    return this.authors.getAuthor(name);\n  }\n\n  /**\n   * Method that creates a variable. This method can also be used to overwrite variables with the same name\n   * as a way to update fields.\n   *\n   * @param {{\n   *     type?: string;\n   *     name: string; // required\n   *     description?: string | {};\n   *     value?: string; // string, boolean, or number\n   *     identifier?: string; // identifier that distinguish across dataset (URL), confusing should check description\n   *     minValue?: number;\n   *     maxValue?: number;\n   *     levels?: string[] | []; // technically property values in the other one but not sure how to format it\n   *     levelsOrdered?: boolean;\n   *     na?: boolean;\n   *     naValue?: string;\n   *     alternateName?: string;\n   *     privacy?: string;\n   *   }} fields - Fields associated with the current Psych-DS standard.\n   */\n  setVariable(fields: {\n    type?: string;\n    name: string; // required\n    description?: string | {};\n    value?: string; // string, boolean, or number\n    identifier?: string; // identifier that distinguish across dataset (URL)\n    minValue?: number;\n    maxValue?: number;\n    levels?: string[] | []; // technically property values in the other one but not sure how to format it\n    levelsOrdered?: boolean;\n    na?: boolean;\n    naValue?: string;\n    alternateName?: string;\n    privacy?: string;\n  }): void {\n    this.variables.setVariable(fields);\n  }\n\n  /**\n   * Allows you to access a variable's information by using the name of the variable. Can\n   * be used to update fields within a variable, but suggest using updateVariable() to prevent errors.\n   *\n   * @param {string} name - Name of variable to be accessed\n   * @returns {{}} - Returns object of fields\n   */\n  getVariable(name: string): {} {\n    return this.variables.getVariable(name);\n  }\n\n  containsVariable(name: string): boolean {\n    return this.variables.containsVariable(name);\n  }\n\n  /**\n   * Allows you to update a variable or add a value in the case of updating values. In other situations will\n   * replace the existing value with the new value.\n   *\n   * @param {string} var_name - Name of variable to be updated.\n   * @param {string} field_name - Name of field to be updated.\n   * @param {(string | boolean | number | {})} added_value - Value to be used in the update.\n   */\n  updateVariable(\n    var_name: string,\n    field_name: string,\n    added_value: string | boolean | number | {}\n  ): void {\n    this.variables.updateVariable(var_name, field_name, added_value);\n  }\n\n  /**\n   * Allows you to delete a variable by key/name.\n   *\n   * @param {string} var_name - Name of variable to be deleted.\n   */\n  deleteVariable(var_name: string): void {\n    this.variables.deleteVariable(var_name);\n  }\n\n  /**\n   * Gets a list of all the variable names.\n   *\n   * @returns {string[]} - List of variable string names.\n   */\n  getVariableNames(): string[] {\n    return this.variables.getVariableNames();\n  }\n\n  /**\n   * Method that allows you to display metadata at the end of an experiment.\n   *\n   * @param {string} [elementId=\"jspsych-metadata-display\"] - Id for how to style the metadata. Defaults to default styling.\n   */\n  displayMetadata(display_element) {\n    const elementId = \"jspsych-metadata-display\";\n    const metadata_string = JSON.stringify(this.getMetadata(), null, 2);\n    // const display_element = this.JsPsych.getDisplayElement();\n    display_element.innerHTML += `<p id=\"jspsych-metadata-header\">Metadata</p><pre id=\"${elementId}\" class=\"jspsych-preformat\"></pre>`;\n    document.getElementById(elementId).textContent += metadata_string;\n  }\n\n  /**\n   * Method that begins a download for the dataset_description.json at the end of experiment.\n   * Allows you to download the metadat.\n   */\n  saveAsJsonFile(): void {\n    const jsonString = JSON.stringify(this.getMetadata(), null, 2);\n    const blob = new Blob([jsonString], { type: \"application/json\" });\n    const url = URL.createObjectURL(blob);\n\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = \"dataset_description.json\";\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n\n    URL.revokeObjectURL(url);\n  }\n\n  // passing in authors mapping and variables mapping and then goes through each variable\n  async generate(data, metadata = {}) {\n    // have it so that can pass in a dict of object that the researcher wants to do\n    if (typeof data === \"string\") {\n      data = JSON.parse(data);\n    }\n\n    for (const observation of data) {\n      await this.generateObservation(observation);\n    }\n\n    for (const key in metadata) {\n      this.processMetadata(metadata, key);\n    }\n    console.log(this.cache);\n    this.getMetadata();\n  }\n\n  private async generateObservation(observation) {\n    // variables can be thought of mapping of one column in a row\n    const pluginType = observation[\"trial_type\"];\n    const ignored_fields = new Set([\"trial_type\", \"trial_index\", \"time_elapsed\"]);\n\n    for (const variable in observation) {\n      const value = observation[variable];\n\n      if (ignored_fields.has(variable)) this.updateFields(variable, value, typeof value);\n      else if (this.containsVariable(variable)) {\n        // logic updates existing variable\n        await this.generateUpdate(variable, value, pluginType);\n      } else {\n        // logic to create new variable\n        await this.generateVariable(variable, value, pluginType);\n      }\n    }\n  }\n\n  private async generateVariable(variable, value, pluginType) {\n    // probably should work in a call to the plugin here\n    const description = await this.getPluginInfo(pluginType, variable);\n    const type = typeof value;\n\n    // probs should have update description called here\n    const new_var = {\n      type: \"PropertyValue\",\n      name: variable,\n      // If a description is not found from getPluginInfo, we pass a placeholder string\n      // instead of null so the system doesn't break *why doesn't null work?(promise error)*\n      description: description ? { [pluginType]: description } : { [pluginType]: \"unknown\" },\n      value: type,\n    };\n\n    this.setVariable(new_var);\n    this.updateFields(variable, value, type);\n  }\n\n  // hardest part is updating the description\n  // want to hardcode in the variables check\n  // logic is that probably won't need to be doing the dict thing\n  // implement all as description\n  private async generateUpdate(variable, value, pluginType) {\n    const type = typeof value;\n    const field_name = \"description\";\n    const description = await this.getPluginInfo(pluginType, variable);\n\n    // If a description is not found from getPluginInfo, we pass a placeholder string\n    // instead of null so the system doesn't break *why doesn't null work?(promise error)*\n    const new_description = description\n      ? { [pluginType]: description }\n      : { [pluginType]: \"unknown\" };\n\n    this.updateVariable(variable, field_name, new_description);\n    this.updateFields(variable, value, type);\n  }\n\n  private updateFields(variable, value, type) {\n    // calls updates where updateVariable handles logic\n    if (type !== \"number\" && type !== \"object\") {\n      this.updateVariable(variable, \"levels\", value);\n    }\n    // calls updates where updateVariable handles logic\n    if (type === \"number\") {\n      this.updateVariable(variable, \"minValue\", value);\n      this.updateVariable(variable, \"maxValue\", value);\n    }\n  }\n\n  private processMetadata(metadata, key) {\n    const value = metadata[key];\n\n    if (key === \"variables\") {\n      if (typeof value !== \"object\" || value === null) {\n        console.error(\"Variable object is either null or incorrect type\");\n        return;\n      }\n\n      // all of the variables must already exist because should have datapoints\n      for (let variable_key in value) {\n        if (!this.containsVariable(variable_key)) {\n          console.error(\"Metadata does not contain variable:\", variable_key);\n          continue;\n        }\n\n        const variable_parameters = value[variable_key];\n\n        if (typeof variable_parameters !== \"object\" || variable_parameters === null) {\n          console.error(\n            \"Parameters of variable:\",\n            variable_key,\n            \"is either null or incorrect type. The value\",\n            variable_parameters,\n            \"is either null or not an object.\"\n          );\n          continue;\n        }\n\n        for (const parameter in variable_parameters) {\n          // calling updates for each of the renamed parameters within variable/errors handled by method call\n          const parameter_value = variable_parameters[parameter];\n          this.updateVariable(variable_key, parameter, parameter_value);\n          if (parameter === \"name\") variable_key = parameter_value; // renames future instances if changing name\n        }\n      }\n    } else if (key === \"author\") {\n      if (typeof value !== \"object\" || value === null) {\n        console.error(\"Author object is not correct type\");\n        return;\n      }\n\n      for (const author_key in value) {\n        const author = value[author_key];\n        if (!(\"name\" in author)) author[\"name\"] = author_key;\n        this.setAuthor(author);\n      }\n    } else this.setMetadataField(key, value);\n  }\n\n  /**\n   * Gets the description of a variable in a plugin by fetching the source code of the plugin\n   * from a remote source (usually unpkg.com) as a string, passing the script to getJsdocsDescription\n   * to extract the description for the variable (present as JSDoc); caches the result for future use.\n   *\n   * @param {string} pluginType - The type of the plugin for which information is to be fetched.\n   * @param {string} variableName - The name of the variable for which information is to be fetched.\n   * @returns {Promise<string|null>} The description of the plugin variable if found, otherwise null.\n   * @throws Will throw an error if the fetch operation fails.\n   */\n  private async getPluginInfo(pluginType: string, variableName: string) {\n    // Check if the cache for the pluginType exists, if not initialize it\n    if (!this.cache[pluginType]) this.cache[pluginType] = {};\n\n    // If the variable already exists in the cache for the plugin, return the cached value\n    if (variableName in this.cache[pluginType]) {\n      return this.cache[pluginType][variableName];\n    }\n    // If not, we proceed to fetch script:\n\n    // Construct the URL for the unpkg service\n    const unpkgUrl = `https://unpkg.com/@jspsych/plugin-${pluginType}/src/index.ts`;\n\n    try {\n      // Fetch the script content from the unpkg URL\n      const response = await fetch(unpkgUrl);\n      const scriptContent = await response.text();\n\n      // Extract the JSDoc description for the variable from the script content\n      const description = getJsdocsDescription(scriptContent, variableName);\n\n      // Check again if the cache for the pluginType exists, if not initialize it\n      if (!this.cache[pluginType]) this.cache[pluginType] = {};\n\n      // Cache the description for the variable in the pluginType cache\n      this.cache[pluginType][variableName] = description;\n\n      // Return the description\n      return description;\n    } catch (error) {\n      console.error(`Failed to fetch info from ${unpkgUrl}:`, error);\n      // Error is likely due to 1)a fetch failure, or 2)no JSDoc comments in the script content matched.\n\n      //HANDLE FETCH FAILURE CASES\n\n      // In case of the latter, we cache the null value to prevent repeated fetch attempts.\n\n      if (!this.cache[pluginType]) this.cache[pluginType] = {};\n\n      this.cache[pluginType][variableName] = null;\n\n      return null;\n    }\n  }\n}\n\n/**\n * Extracts the description for a variable of a plugin from the JSDoc comments present in the script of the plugin. The script content is\n * drawn from the remotely hosted source file of the plugin through getPluginInfo. The script content is taken\n * as a string and Regex is used to extract the description.\n *\n *\n * @param {string} scriptContent - The content of the script from which the JSDoc description is to be extracted.\n * @param {string} variableName - The name of the variable for which the JSDoc description is to be extracted.\n * @returns {string} The extracted JSDoc description, cleaned and trimmed.\n */\nfunction getJsdocsDescription(scriptContent: string, variableName: string) {\n  // Regex to match part of the content that starts with 'parameters:' and ends with '};', which\n  // is parameters info. THIS MUST BE CHANGED TO data FOR NEW PLUGIN LAYOUT\n  const paramRegex = scriptContent.match(/parameters:\\s*{([\\s\\S]*?)};\\s*/).join();\n\n  // Regex that matches everything up to the variable name\n  const regex = new RegExp(`((.|\\n)*)(?=${variableName}:)`);\n\n  // Regex on paramRegex, to get everything from 'paramaters:' to the variable name.\n  const variableRegex = paramRegex.match(regex)[0];\n\n  // Finds the index of the last occurence of `/**` in the variableRegex string, and slices it from there\n  // to give the JSDoc comment for our variable.\n  const descrip = variableRegex.slice(variableRegex.lastIndexOf(\"/**\"));\n\n  // Regex to remove the leading and trailing '/**' and '*/' characters.\n  const clean = descrip.match(/(?<=\\*\\*)([\\s\\S]*?)(?=\\*\\/)/)[1];\n\n  //CLEANING:\n  // Regex to remove all newline characters.\n  const cleaner = clean.replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n\n  // Remove all '*' characters from the JSDoc comment.\n  const cleanest = cleaner.replace(/\\*/gm, \"\");\n\n  // Return the cleaned JSDoc comment, trimmed of leading and trailing whitespace\n  return cleanest.trim();\n}\n"],"names":["AuthorsMap","author_list","key","fields","new_author","name","VariablesMap","trial_type_var","trial_index_var","time_elapsed_var","var_list","variable","description","numKeys","new_variable","var_name","field_name","added_value","updated_var","add_key","add_value","exists","value","old_name","added_var","field","t","e","s","a","JsPsychMetadata","JsPsych","res","display_element","elementId","metadata_string","jsonString","blob","url","_0","__async","data","metadata","observation","pluginType","ignored_fields","type","new_var","new_description","variable_key","variable_parameters","parameter","parameter_value","author_key","author","variableName","unpkgUrl","scriptContent","getJsdocsDescription","error","paramRegex","regex","variableRegex"],"mappings":"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"}